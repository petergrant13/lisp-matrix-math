(defun make-matrix (rows cols &optional (init 0))
  (make-array (list rows cols) :initial-element init))

(defun print-matrix (M)
  (dotimes (i (array-dimension M 0))
    (dotimes (j (array-dimension M 1))
      (format t "~3a " (aref M i j)))
    (terpri)))

(defun identity-matrix (n)
  (let ((m (make-matrix n n)))
    (dotimes (i n)
      (setf (aref m i i) 1))
    m))

(defun matrix-add (A B)
  "Add two matrices A and B. Throws an error if dimensions are incompatible."
  (unless (and (= (array-dimension A 0) (array-dimension B 0))
               (= (array-dimension A 1) (array-dimension B 1)))
    (error "Matrix dimensions do not match: ~A vs ~A"
           (array-dimensions A)
           (array-dimensions B)))
  (let* ((rows (array-dimension A 0))
         (cols (array-dimension A 1))
         (C (make-array (list rows cols))))
    (dotimes (i rows)
      (dotimes (j cols)
        (setf (aref C i j) (+ (aref A i j) (aref B i j)))))
    C))

(defun matrix-multiply (A B)
  "Multiply two matrices A and B. Throws an error if dimensions are incompatible."
  (unless (= (array-dimension A 1) (array-dimension B 0))
    (error "Matrix dimensions do not allow multiplication: ~A vs ~A"
           (array-dimensions A)
           (array-dimensions B)))
  (let* ((rows (array-dimension A 0))
         (cols (array-dimension B 1))
         (inner (array-dimension A 1))
         (C (make-array (list rows cols) :initial-element 0)))
    (dotimes (i rows)
      (dotimes (j cols)
        (dotimes (k inner)
          (incf (aref C i j) (* (aref A i k) (aref B k j))))))
    C))

(defun transpose (M)
  "Return the transpose of matrix M."
  (let* ((rows (array-dimension M 0))
         (cols (array-dimension M 1))
         (MT (make-array (list cols rows))))
    (dotimes (i rows)
      (dotimes (j cols)
        (setf (aref MT j i) (aref M i j))))
    MT))
